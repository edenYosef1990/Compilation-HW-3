%{
	#include "attributes.h"
    #include "SymbolTable.h"
    #include "output.hpp"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;

	extern int yylex();
    extern int yylineno;
	int yyerror(char const*);

    SymbolTable symbolTable;
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left AND
%left OR
%right NOT
%token TRUE
%token FALSE
%token RETURN
%token IF

%nonassoc "then"
%nonassoc ELSE

%token WHILE
%token BREAK
%token CONTINUE
%token PRECOND
%token SC
%token COMMA
%right LPAREN RPAREN
%right LBRACE RBRACE
%left ASSIGN
%nonassoc  RELOP
%left  BINOP
%token ID
%token NUM
%token STRING


%%

Program  : 
    Funcs 
;
Funcs : 
    /*epsilon*/ | FuncDecl Funcs 
;
FuncDecl :
    RetType ID LPAREN Formals RPAREN PreConditions LBRACE Statements RBRACE 
;
RetType : 
    Type | VOID
;
Formals : 
    /*epsilon*/ | FormalsList
;
FormalsList : 
    FormalDecl | FormalDecl COMMA FormalsList
;
FormalDecl : 
    Type ID
;
PreConditions : 
    /*epsilon*/ | PreConditions PreCondition
;
PreCondition : 
	PRECOND LPAREN Exp RPAREN
;
Statements : 
    Statement | Statements Statement
;
Statement : 
    LBRACE Statements RBRACE | 
    Type ID SC {
        enum TypeNameEnum type = symbolTable.GetTypeOfSymbol((dynamic_cast<IdVal*>($2))->IdStr);
        if(type != TYPE_NONE){
            output::errorDef(yylineno,(dynamic_cast<IdVal*>($2))->IdStr);
            exit(0);
        }
    }| 
    Type ID ASSIGN Exp SC { 
        enum TypeNameEnum type = symbolTable.GetTypeOfSymbol((dynamic_cast<IdVal*>($2))->IdStr);
        if(type != TYPE_NONE){
            output::errorDef(yylineno,(dynamic_cast<IdVal*>($2))->IdStr);
            exit(0);
        }
        if(dynamic_cast<Type*>($1)->name != dynamic_cast<DataObj*>($4)->type){
            output::errorMismatch(yylineno);
        }
    }
    | 
    ID ASSIGN Exp SC {
        enum TypeNameEnum type = symbolTable.GetTypeOfSymbol((dynamic_cast<IdVal*>($1))->IdStr);
        if(type == TYPE_NONE){
            output::errorUndef(yylineno, (dynamic_cast<IdVal*>($1))->IdStr);
        }
        if(type != dynamic_cast<DataObj*>($3)->type){
            output::errorMismatch(yylineno);
        }
    }| 
    IF LPAREN Exp RPAREN Statement %prec "then" |
    IF LPAREN Exp RPAREN Statement ELSE Statement |
    WHILE LPAREN Exp RPAREN Statement |
    BREAK SC | CONTINUE SC
;

Call :
    ID LPAREN ExpList RPAREN |
    ID LPAREN RPAREN 
;
ExpList :
    Exp COMMA ExpList | Exp
;
Type :
    INT{ $$ = new Type(TYPE_INT);} |
     BYTE { $$ = new Type(TYPE_BYTE); } |
      BOOL { $$ = new Type(TYPE_BOOL); }
;
Exp :
    ID {
        TypeNameEnum type = symbolTable.GetTypeOfSymbol
        ((dynamic_cast<IdVal*>(yylval))->GetVal());
        std::string name = (dynamic_cast<IdVal*>(yylval))->GetVal();
        Symbol * sym =  symbolTable.GetSymbol(name);
        switch(type){
            case TYPE_FUNC:{     FunctionSymbol * funcSym = dynamic_cast<FunctionSymbol*>(sym);
                                $$ = new NonTermFunc(funcSym->GetName(),funcSym->GetParametersList(),funcSym->GetRetType()); 
                                break;
                            }
            case TYPE_INT: $$ = new NonTermInt(name); break;
            case TYPE_B: $$ = new NonTermB(name); break;
            case TYPE_BYTE: $$ = new NonTermByte(name); break;
            case TYPE_BOOL: $$ = new NonTermBool(name); break;
            case TYPE_STR: $$ = new NonTermStr(name); break;
            case TYPE_NONE: $$ = new IDNotExists(name); break;
        }
    }|
    Call | /* translate a function into an Expression , so an Exp object which is a variable cant be a function anyway */
    NUM {$$ = new NonTermInt($1);} |
    NUM B {
        if( IsItConstOrExistingSymbol(dynamic_cast<DataObj*>($1)) && NonTermB::IsValidB($1) )
        {
            $$ = new NonTermB();
        }
     } |
    STRING {
        $$ = new NonTermStr();
        } |
    TRUE {
        $$ = new NonTermBool();
        }|
    FALSE {
        $$ = new NonTermBool();
        } |
	Exp AND Exp {
        if(NonTermBool::IsValidBoolExp($1,$2,$3))
        {
            $$ = new NonTermBool();
        }   
    } |
    Exp OR Exp {
        if(NonTermBool::IsValidBoolExp($1,$2,$3))
        {
            $$ = new NonTermBool();
        }   
    } |
    Exp RELOP Exp {
        if(NonTermBool::IsValidBoolExp($1,$2,$3))
        {
            $$ = new NonTermBool();
        }   
    } |
    NOT Exp {
        if(NonTermBool::IsValidBoolExp($1))
        {
            $$ = new NonTermBool();
        }   
    } 

    
;

%%

int main()
{
    symbolTable = SymbolTable();
	yyparse();
}

int yyerror(char const* message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}
